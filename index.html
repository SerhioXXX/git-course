<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Git command</title>
</head>
<body>
  <h1>Hello Git</h1>
  <a href="https://learngitbranching.js.org/?locale=ru_RU">https://learngitbranching.js.org/?locale=ru_RU</a>
  <p><b>git rm --cached < 'file ></b> -> отписываем файл от слежения git'om</p>
  <p><b>git branch </b> -> список веток</p>
  <p><b>git branch test</b> -> создаем ветку test</p>
  <p><b>git branch -D test</b> -> удаляет ветку test</p>
  <p><b>git checkout -b test</b> -> создаем и переключаемся в ветку test</p>
  <p><b>git merge readme </b>-> мержит в нашу текущую ветку - ветку readme</p>
  <p> <b>git config --global user.name</b> -> выводим наше имя для git</p>
  <p><b>git config --global user.name "Serhii"</b>  -> задаем наше имя для git - Serhii</p>
  <p> <b>git config --global user.email</b> -> выводим наше email для git</p>
  <p><b>git config --global user.email "test@mail.ru"</b>  -> задаем наше email для git - test@mail.ru</p>
  <p><b>git branch -M main</b> -> переименовываем главную ветку в main</p>
  <p><b>git remote add origin https://github.com/serhioxxx/git-course.git </b> -> приаязываем наш локально созданный репозиторий к удаленному репозиторию(https://xxx) на git</p>
  <p><b>git push -u origin main </b>-> заливает то что на локальном репозитории в удаленный сервер git</p>
  <p><b>git rebase master</b> -> находившись в ветке bugFix выполнив команду сдвигаем изменения из bugFix в конец ветки master образуя линейную последовательность коммитов.
    Единственная проблема - ветка master не обновлена до последних изменений поэтому на ветке master выполняем -> git rebase bugFix </p>
  <p><b>git log</b> -> чтобы найти hash нужного коммита</p>
  <p><b>git checkout master^</b> -> переключение на предыдущий коммит .Так что master^ означает "первый родитель ветки master". master^^ означает прародитель (родитель родителя) master</p>
  <p><b>git checkout HEAD~4</b> -> переходим выше на 4 коммита</p>
  <p><b>git branch -f master HEAD~3</b> -> Перемещение ветки (branch forcing). Переместит (принудительно) ветку master на три родителя назад от HEAD. опция -f означает прикрепить ветку к коммиту</p>
  <p><b>git reset HEAD~1 </b>-> отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было</p>
  <p><b>git revert HEAD </b>-> Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.
    Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert -> новый коммит C2' просто содержит изменения, полностью противоположные тем, что сделаны в коммите C2 (история не переписывается а как бы 2 коммита, коммит отмененяющий(обратный) )
    После revert можно сделать push и поделиться изменениями с остальными.</p>
  <p><b>git cherry-pick  <'Commit1> <'Commit2> <...></b> -> Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). Мы обожаем cherry-pick за то, что в нём очень мало магии и его очень просто понять и применять.</p>
  <p><b>git rebase -i HEAD~4</b> -> отсчитает вверх по комитам и переставит HEAD а также предоставит выбор среди этих  4 коммитов перепрыгнувших коммитов выбор (omit - опустить pick - выбрать), потом в новую ветку накатит эти коммиты которые мы выбрали в той последовательности которую мы укажем. Более гибкий cherry-pick практически</p>
  <b>Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (newImage) и другие изменения (caption), которые связаны так, что находятся друг поверх друга в репозитории.
    Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять newImage, несмотря на то, что коммит уже в прошлом:!</b><br>
    <i>Переставить коммит так, чтобы нужный находился наверху при помощи <quote>git rebase -i</quote><br>
      Внести изменения при помощи <quote>git commit --amend</quote><br>
      Переставить всё обратно при помощи <quote>git rebase -i</quote><br>
      И наконец, переместить master на изменённую часть дерева, чтобы закончить уровень.</i>

  <p><b>git tag V1 C1</b> -> назвали тег V1 и заставили его ссылаться на коммит C1 явным образом. Если конкретный коммит не указан, гит пометит тегом HEAD.</p>
  <p><b>git describe <'ref></b> -> Где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).</p>
  <b>Вывод команды git describe выглядит примерно так:</b><br>
  <quote><'tag>_<'numCommits>_g<'hash></quote><br>
  <p>Где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.</p>
  <p><b>git pull --rebase</b> -> аналог для совместно вызванных fetch и rebase (в случае с просто pull происходить merge )! Рекомендую для скачивания последних изменений с удалленого репозитория</p>
  <p><b>git checkout -b totallyNotMaster o/master</b> -> создаст новую ветку с именем totallyNotMaster и укажет ей следить за o/master</p>
  <p><b>git branch -u o/master foo</b> -> укажете ветке foo следить за o/master. А если вы ещё при этом находитесь на ветке foo, то её можно не указывать: -> git branch -u o/master</p>
  <p><b>git push <'удалённый_репозиторий> <'целевая_ветка></b> -> например команда: git push origin master -> Дословно можно перевести как: <i>Перейди в ветку с именем "master" в моём локальном репозитории, возьми все коммиты и затем перейди на ветку "master" на удалённом репозитории "origin.". На эту удалённую ветку скопируй все отсутствующие коммиты, которые есть у меня, и скажи, когда ты закончишь.</i></p>
  <p><b>git push origin <'источник>:<'получатель></b> -> берет коммиты из <'источник> (например можно указать просто HEAD~1 или foo^ ) и обновляет <'получатель> , например : git push origin foo^:master -> на удаленном репозитории (origin) обновим ветку master коммитами из foo^ (это предпоследний коммит в ветке foo)</p><br>
  <p><b>git push origin master:newBranch</b> -> А что если пункт назначения, в который вы хотите запушить, не существует? Без проблем! Укажите имя ветки в нашем случае newBranch, и git сам создаст ветку на удалённом репозитории для вас.</p>
  <p><b>git fetch origin foo</b> -> Git отправится в ветку foo на удалённом репозитории, соберёт с собой все коммиты, которые не присутствуют локально, и затем поместит их в локальную ветку под названием o/foo</p>
  <p><b>git fetch origin foo~1:bar</b> -> git отправится на удаленную ветку foo~1 возьмет коммиты и скопирует их в нашу локальную bar (если ее не будет то создаст)</p>
  <p><b>git fetch</b> -> скачивает все-все коммиты с удалённого репозитория и помещает их в соответствующие удалённо-локальные ветки в локальном репозитории origin/foo и origin/bar к примеру, в локальных foo и bar без изменений</p>
  <p><b>git push origin :foo</b> -> удалить ветку foo в удаленном репозитории</p>
  <p><b>git fetch origin :bar</b> -> создаст ветку bar в локальном репозитории</p>
  <p><b>git pull origin foo</b> -> это то же самое, что сделать: git fetch origin foo; git merge o/foo</p>
  <p><b>git pull origin bar~1:bugFix</b> -> то же, что: git fetch origin bar~1:bugFix; git merge bugFix</p>
  <p><b>git pull origin master:foo</b> -> Тут немного магии: запустивши команду находясь в локальной ветке bar мы сначала создадим локальную ветку foo далее скачаем в нее коммиты из удаленной ветки master и смержим foo c bar</p>

</body> 
<script src="script.js"></script>
</html>